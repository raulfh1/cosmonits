<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8" />
  <title>Webcam amb Delay Visual Sense getImageData</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f0f0f0;
      margin: 0;
      padding: 1em;
    }
    #delayed {
      background: black;
      border: 2px solid #333;
      width: 640px;
      height: 480px;
      display: block;
      margin: 1em auto;
    }
    label, input, button {
      font-size: 1.1rem;
      margin: 0.5em;
    }
    #controls {
      margin-bottom: 1em;
    }
  </style>
</head>
<body>
  <h1>Webcam amb Delay Visual Sense getImageData</h1>
  
  <div id="controls">
    <label for="delaySlider">Delay (ms): <span id="delayValue">2000</span></label>
    <input type="range" id="delaySlider" min="0" max="5000" step="100" value="2000">
    <button id="fullscreenBtn">Pantalla completa</button>
  </div>
  
  <canvas id="delayed" width="640" height="480"></canvas>

  <script>
    const canvas = document.getElementById('delayed');
    const ctx = canvas.getContext('2d');
    const delaySlider = document.getElementById('delaySlider');
    const delayValue = document.getElementById('delayValue');
    const fullscreenBtn = document.getElementById('fullscreenBtn');

    let delay = parseInt(delaySlider.value, 10);
    delayValue.textContent = delay;

    // Buffer de canvas temporals per emmagatzemar frames
    const frames = [];

    // Vídeo ocult per capturar webcam
    const video = document.createElement('video');
    video.autoplay = true;
    video.muted = true;
    video.playsInline = true;
    video.style.display = 'none';
    document.body.appendChild(video);

    delaySlider.addEventListener('input', () => {
      delay = parseInt(delaySlider.value, 10);
      delayValue.textContent = delay;
    });

    fullscreenBtn.addEventListener('click', () => {
      if (canvas.requestFullscreen) {
        canvas.requestFullscreen();
      } else if (canvas.webkitRequestFullscreen) { /* Safari */
        canvas.webkitRequestFullscreen();
      } else if (canvas.msRequestFullscreen) { /* IE11 */
        canvas.msRequestFullscreen();
      }
    });

    navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
      video.srcObject = stream;

      video.addEventListener('loadedmetadata', () => {
        canvas.width = video.videoWidth || 640;
        canvas.height = video.videoHeight || 480;
        drawFrame();
      });
    }).catch(err => {
      alert("No s'ha pogut accedir a la càmera: " + err.message);
    });

    function drawFrame() {
      // Creem un canvas temporal per guardar el frame actual
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(video, 0, 0, canvas.width, canvas.height);

      // Guardem el canvas amb timestamp
      frames.push({ time: Date.now(), canvas: tempCanvas });

      // Cerquem frame amb retard
      const now = Date.now();
      const delayedIndex = frames.findIndex(f => now - f.time >= delay);

      if (delayedIndex !== -1) {
        // Passem al canvas principal el frame amb retard
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(frames[delayedIndex].canvas, 0, 0, canvas.width, canvas.height);

        // Netejem frames antics
        frames.splice(0, delayedIndex + 1);
      }

      requestAnimationFrame(drawFrame);
    }
  </script>
</body>
</html>
